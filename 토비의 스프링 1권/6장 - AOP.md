# 6장 - AOP

## 6.1 트랜잭션 코드의 분리

- 트랜잭션과 비지니스 로직이 서로 독립적인 코드일 때 비지니스 로직을 담당하는 코드를 메소드로 추출하기

![2E30C1CE-AC65-4C46-8F6E-A724B3188646.jpeg](IMG%2F2E30C1CE-AC65-4C46-8F6E-A724B3188646.jpeg)

- DI적용을 위한 트랜젝션 분리

![017B74CF-B517-4154-9A4F-DDA3A7B9A8C3.jpeg](IMG%2F017B74CF-B517-4154-9A4F-DDA3A7B9A8C3.jpeg)

- UserService클래스를 간접적으로 사용할 수 있도록 DI(클라이언트와의 결합 Down, 유연한 확장가능)
    - UserServiceImpl - 비지니스 로직을 담고있음
    - UserServiceTx - 트랜잭션 경계를 설정함.
    - 사용 순서 : Client → UserServiceTx → UserService(UserServiceImpl DI)
- 트랜잭션과 비지니스 로직 분리로 인한 테스트 변경시 주의사항
    - 테스트 수정 시 이름이 동일한 두개의 클래스 타입의 빈을 @Autowired로 가져올 경우 타입으로 검색 시 하나으 빈을 결정 할 수 없는 경우 필드이름을 사용해서 빈을 찾기 때문에 정확한 변수명 설정 필요.
    - 목오브젝트를 이용해 수동으로 DI적용 시 클래스 오브젝트 명시  필요
- 트랜잭션 경계설정 코드 분리의 장점
    1. 비지니스 로직 수정 시 기술내용(ex.트랜잭션) 수정 X
    2. 비지니스 로직 테스트 용이

## 6.2 고립된 단위테스트

- 가장 좋은 테스트 방법은 가능한 작은 단위로 쪼개서 테스트 하는 것(테스트 실패 원인 찾기 쉬움)
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위 테스트의 장점을 얻기 어려움

![1A04CB81-CD4A-4716-8CE2-2813079186FF.jpeg](IMG%2F1A04CB81-CD4A-4716-8CE2-2813079186FF.jpeg)

- UserService테스트대상에  많은 오브젝트, 서버, 네트워크 등이 포함되므로 테스트의 대상이 환경이나 외부서버, 다른 클래스코드에 종속되고 영향받지 않도록 고립시킬 필요가 있다.
- 단위테스트
    - 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트
- 통합테스트
    - 두개이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들거나 외부의 DB나 파일, 서비스등의 리소스가 참여하도록 하는 테스트
- 둘 중 어떤 테스트를 사용할까?
    - 항상 단위 테스트를 먼저 고려
    - 성격과 목적이 같은 긴밀한 클래스들을 모아 외부와의 의존관계 차단. 필요 시 테스트 대역을 이용
    - 외부 리소스를 사용해야만 하는 테스트는 통합테스트 사용
    - DAO는 DB를 통해 로직을 수행하는 인터페이스 같은 역할을 하므로 단위테스트 어려움 그러나 DAO를 이용하는 코드는 DAO역할을 스텁이나 목 오브젝트 프로젝트로 대체해서 테스트 가능
    - 의존관계가 있을 시 통합테스트가 필요
    - 단위테스트를 만들기 복잡한 코드는 통합테스트 고려(가능한 많은 부분을 단위테스트 하면 좋음)
    - 스프링  테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합테스트
- 목프레임워크 (대표적 Mockito)
    - 목프레임워크를 일일히 준비할 필요 없음.
    - Mockito의 스테틱 메소드 호출로 만들어짐
        - mock();
    - 목오브젝트의  사용법
        - 인터페이스를 이요해 목 오브젝트를 만들기
        - 목오브젝트의 리턴값 존재 시 지정 필요
        - 테스트 대상 오브젝트에 DI 해서 목오브젝트가 테스트 중에 사용되도록 만들기
        - 목오브젝트의 특정 메소드 호출 여부와 호출 수, 어떤 값을 가지고 몇번 호출됐는지 검즈ㅡㅇ

## 6.3 다이내믹 프록시와 팩토리 빈

- 프록시 :  실제대상인것처럼 위장해서 클라이언트의 요청을 받아주는 대리인과 같은 역할
- 타깃(실체) :프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제오브젝트
- 프록시는 사용목적에 따라 두가지로 구분
    - 클라이언트가 타겟에 접근하는 방법을 제어하기 위해서 사용
    - 타깃에 부가적인 기능을 부여해주기 위해서 사용
- 데코레이터패턴
    - 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
    - 같은 인터페이스를 구현한 타겟과 여러개의 프록시를 만들 수 있음
    - 데코레이터는 위임대상을 알 수 없음. 따라서 다음 위임대상을 인터페이스로 선언 필요.
    - 생성자나 수정자 메소드를 통해 외부에서 런타임시 주입받을 수 있도록 만들어야 함.
    - 인터페이스를 통한 데코레이터 정의와 런탕ㅁ시의 다이내믹한 구성방법은 스프링의 DI를 이용하면 편리
- 프록시패턴
    - 클라이언트가 타깃에 접근방법을 제어하는 목적으로 사용
    - 클라이언트에게 타깃에 대한 레퍼런스를 넘길 때 실제 타깃 대신 프록시를 넘겨줌. 프록시의 메소드를 통해 타깃을 사용시도 시 프록시가 타겟오브젝트를 생성하고 요청을 위임해주는 방식
    - 레퍼런스를 가지고 있지만 끝까지 사용하지 않거나 많은  작업이 진행된 후 사용시 프록시를 통해 생성을 늦추기 좋음.

### 다이내믹 프록시

- Java.lang.reflect 패키지 안에 프록시를 손쉽게 생성하도록 지원하는 클래스 존재
- 프록시 클래스를 정의하지 않고도 몇가지 API를 이용해 프록시처럼 동작하는 오브젝트를 다이나믹하게 생성
- 프록시 구성
    - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃으로 오브젝트 위임
    - 지정된 요청에 대해서는 부가기능을 수행
- 프록시구성시 문점
    - 타깃의 인터페이스를구현하고 위임하는 코드 작성이 번거로움
    - 부가기능 코드가 중복될 가능성이 많음
- 리플랙션 기능
    - 자바의 코드를 추상화해서 만든 것으로 java.llang.reflect.Method는 메소드에 대한 자세한 정보를 가지고 있고, 특정오브젝트의 메소드를 실행 시킬 수 있음
        - invoke() 사용 - 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 반환
        
- 다이나믹 프록시의 작동방식

    ![ch6Untitled.png](IMG%2Fch6Untitled.png)
    
- 다이내믹 프록시
    - 프록시 팩토리에 의해서 런타임시 다이나믹하게 만들어지는 오브젝트
    - 타깃의 인터페이스와 같은 타입으로 만들어짐.  1

---

---

### 다이내믹 프록시를 위한 팩토리빈

- 스프링은 내부적으로 리플렉션 API를 이용하여 빈 정의에  나오는 클래스 이름을 가지고 빈 오브젝트를 생성하는데 다이내믹 프록시는 클래스 자체도 내부적으로 다이내믹하게 정의하기 때문에 클래스 정보를 알 수 없음.
- 팩토리빈: 스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 빈
- 팩토리빈을 만드는 방법
    - FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로  등록하면 팩토리 빈으로 동작
- 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져와 빈 오브젝트로 사용한다.
- 팩토리빈의 getObject() 메소드 내에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 다이내믹프록시 오브젝트를 스프링의 빈드로  만들 수 있음.
- 프록시 팩토리빈의 장점
    - 다이내믹 프록시를 사용하면 타깃인터페이스를 일일히 구현하는 수고로움을 덜 수  있음
    - 하나에 핸들러에 여러 부가기능을 넣을 수 있음.
- 프록시 팩토리빈의 한계
    - 클래스안에 존재하는 여러개의 메소드에 한번에 공통적인 부가기능 생성 불가
    - 하나의 타깃에 여러개의 부가기능 적용 불가
    - 동일한 부가기능을 제공하는 코드라도 타깃오브젝트가 달라지면 계속해서 새로운 TransactionHandler를 만들어야 함.

## 6.4 스프링의 프록시 팩토리빈

- ProxyFactoryBean : 프록시를 생성해서 빈  오브젝트로 등록하게 해주는 팩토리  빈
- 어드바이스 : 타깃이 필요없는 순수한 부가기능
    - 전달받은  오브젝트(메소드와 타깃정보 포함)는 콜백오브젝트로 proceed()메소드를 실행하면 타깃 오브젝트의  메소드를 내부적으로  실행해줌. (템플릿처럼 동작) → 부가기능에만  집중 가능
    - 템플릿 역할을 하는  오브젝트를 싱글톤으로 두고 공유가 가능
    - ProxyFactoryBean 하나로 여러개의 부가기능  추가 가능
    - ProxyFactoryBean내 인터페이스 자동 검출 기능을 사용해 타깃 오브젝트가 구현하는  인터페이스 정보 추출가능
- 포인트컷 :  부가기능  적용 대상 메소드  선정 방법
    - 템플릿 역할을 하는 오브젝트를 여러 프록시가 공유해서 사용할 수 있도록 타깃정보를 갖지않게 만들었기 때문에 특정 패턴을 넣을 수 없음 →  프록시에  부가기능 적용 메소드 선택기능을 넣어   해결 가능
  
    ![53298AF0-F006-421C-9C05-BED1FC77649D.jpeg](IMG%2F53298AF0-F006-421C-9C05-BED1FC77649D.jpeg)

    ![93076A88-49B7-4FBA-83C3-E3A1393BDF40.jpeg](IMG%2F93076A88-49B7-4FBA-83C3-E3A1393BDF40.jpeg)
    
    - 어드바이스:(부가기능을 제공하는 오브젝트) 와 포인트컷 (메소드  선정 알고리즘을 담은오브젝트) 모두 프록시에 DI로 주입되서 사용, 싱글톤 빈으로 등록 가능
- 어드바이저 = 포인트컷(메소드선정알고리즘) + 어드바이스(부가기능)

## 스프링 AOP

- 지금까지는 비지니스 로직에 반복적으로 등장하던 트랜잭션을 투명하게 분리함.
    1. 메소드마다 JDBC try/catch/finally 블록으로 구성된 비슷한 코드가 반복될 때는 바뀌는 부분과 바뀌지 않는 부분을 구분해서 분리하고 템플릿과 콜백, 클라이언트로 나누는 방법을 통해 해결
    2. 반복적인 위임코드가 필요한 프록시 클래스 코드는 다이내믹 프록시라는 런타임 코드 자동생성을 통해 해결
    (의미있는 부가기능 로직인 트랜잭션 경계설정은 코드로 만들게 하고, 기계적인 코드인 타깃인터페이스구현과 위임, 부가기능 연동부분은 자동생성)
    
- 해결해야하는 남은 과제 : 부가기능 적용이 필요한 타깃 오브젝트마다 ProxyFactoryBean 설정정보를 추가해주는 반복되는 부분을 분리 필요

- 포인트컷의 두가지 기능

    ![ct6Untitled 1.png](IMG%2Fct6Untitled%201.png)
    
    - 타깃오브젝트의 메소드 중에서 어떤 메소드에 부가기능을 적용할지 선정(MethodMatcher)
    - 등록된 빈 중에서 어떤 빈에 프록시를 적용할지 선택(ClassFilter)

### DefaltAdvisorAutoProxyCreator의 적용

- 클래스 필터를 적용한 포인트컷 작성

    ![997D5495-118F-4C5E-876E-89106BAC9F3F.jpeg](IMG%2F997D5495-118F-4C5E-876E-89106BAC9F3F.jpeg)
    
    - 메소드 이름만 비교하던 포인트컷인 NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가하도록 만들기
- 어드바이저를 이용하는 자동 프록시 생성기 등록

![2A628F74-5648-455A-A13A-33AED8647D91.jpeg](IMG%2F2A628F74-5648-455A-A13A-33AED8647D91.jpeg)

- 포인트컷 등록

    ![EBAC882D-AFC8-40BC-AE8F-5928F894F609.jpeg](IMG%2FEBAC882D-AFC8-40BC-AE8F-5928F894F609.jpeg)
    
- 어드바이스와                                                                                                                      어드바이저
    - 어드바이저를 이용하는 자동프록시 생성기 등록을 통해 DefaultAdvisorAutoProxyCreator에 의해 자동수집되고 프록시 대상 선정과정에 참여하며,  자동생성된 프록시에 의해 다이나믹하게 DI됨.
- ProxyFactoryBean제거와 서비스 빈의  원상복구

    ![A4E2142C-012B-4448-B9D6-FA841F6E5E97.jpeg](IMG%2FA4E2142C-012B-4448-B9D6-FA841F6E5E97.jpeg)
    
- 자동프록시 생성 테스트

    ![F7E124BD-0225-49DA-9D01-F23E95AB2735.jpeg](IMG%2FF7E124BD-0225-49DA-9D01-F23E95AB2735.jpeg)
    
    ![6F4E7374-BE72-47CB-B9A1-A703F3C23DF2.jpeg](IMG%2F6F4E7374-BE72-47CB-B9A1-A703F3C23DF2.jpeg)
    
    - TestUserService를 직접 빈으로  등록해서 사용하기 위해 클래스 이름을 TestUserServiceImpl이라고 등록한 뒤 사용자 아이디를 클래스에 넣기
  
    ![04B6FD0E-30F6-4767-B8E0-95C11EC4057A.jpeg](IMG%2F04B6FD0E-30F6-4767-B8E0-95C11EC4057A.jpeg)
    
- 자동프록시 확인
 
### 포인트컷 표현식을 이용한 포인트컷

- AspectJExpressionPointcut클래스 사용
    - 포인트컷 표현식을 지원하는 포인트컷
  
    ![FA5B0B39-89C0-4F39-BC52-64DB39555B1C.jpeg](IMG%2FFA5B0B39-89C0-4F39-BC52-64DB39555B1C.jpeg)
    
    - 클래스와 메소드의 선정 알고리즘을 포인트컷 표현식을 이용해 한번에 지정

### AOP란 무엇인가

- 에스팩트 지향 프로그래밍 (Aspect Oriented Programming)

    ![03E064E1-4877-4B80-A21B-216E9A9883C1.jpeg](IMG%2F03E064E1-4877-4B80-A21B-216E9A9883C1.jpeg)
    
    - 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 에스펙트라는 독특한 모듈로 만들어 설계하고 개발하는 방법
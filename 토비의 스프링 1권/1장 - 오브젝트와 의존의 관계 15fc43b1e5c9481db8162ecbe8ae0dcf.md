# 1장 - 오브젝트와 의존의 관계

# **1장 오브젝트와 의존의 관계**

스프링의 가치 = 객체지향 프로그래밍이 가능한 언어 

스프링의 관심대상 : 오브젝트(생성,관계,사용,소멸) + 설계, 

스프링: 오브젝트 설계,구현, 개선의 기준 →프레임워크형태로 제공

## **1.1 초난감 DAO**

(DAO : Data Access Object -DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하는 오브젝트)

**User** : 사용자 정보를 저장하는 오브젝트

- **자바빈 규약**을 따르는 오브젝트를 이용하면 편리
    1. property는 모두 private으로 선언
    2. getter/setter를 통해서 properties를 조작
    3. Serializable을 implement 하여 직렬화 가능
    
    참고:
    

[Spring, JPA에 기본 생성자가 필요한 이유](https://velog.io/@yebali/Spring-JPA%EC%97%90-%EA%B8%B0%EB%B3%B8-%EC%83%9D%EC%84%B1%EC%9E%90%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0)

**UserDao** : 사용자의 정보를 관리하는 오브젝트

DB Connection, SQL문 실행, 결과반환, 예외처리등의 작업

자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스테틱 메소드 (main)을 사용하여 메소드 검증

## **1.2 DAO의 분리**

### 관심사의 분리

- 오브젝트에 대한 설계와 이를 구현한 코드는 끊임없이 변한다.
    - 개발자는 미래를 위해 설계하고 개발해야 한다.
    - 분리와 확장을 고려한 설계를 통해 변경이 일어날 때 필요한 작업을 최소화하고, 변경에 따른 오류를 최소화 할 수 있다.
    - 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
- 관심이 같은 것 끼리는 모으고, 다른 것은 따로 떨어져 있도록 해야한다.

### UserDao리펙토링

- 리팩토링이란? 기존의 코드를 외부의 동작방식에는 변화 없이 내부구조 변경으로 재구성하는 작업 또는 기술
    - UserDao의 관심사 [DB연결, SQL실행, 공유리소스반환]
    - 중복된 코드가 많으면 `독립적인 메소드`로 추출
    - 상속을 통한 확장으로 사용처 맞춤서비스 제공이 가능
- 디자인패턴?
    - 소프트웨어 설계 시 특정상황에서 자주 만나는 문제를 해결하기 위해 사용하는 솔루션
    - 패턴의 이름만으로 설계의 의도와 해결책 설명가능
    - 템플릿메소드패턴
        - 상속을 통해 슈퍼클래스 기능을 확장할 때 사용하는 대표적인 방법
        - 상위 클래스로 분리해서 그 안에 기본적 로직의 흐름을 두고 일부 구현을 하위 클래스에 위임
    - 팩토리메소드패턴
        - 하위 클래스가 오브젝트 생성방법과 클래스를 결정가능
- 상속의 한계점
    - 이미 상속을 사용하고 있는 경우 → 자바클래스는 다중상속 허용 X
    - 다른 두가지 관심사에 대한 상속은 여전히 긴밀한 결합인 편임 (상위 클래스 수정 -> 모든 하위 클래스 수정)

## **1.3 DAO의 확장**

### 클래스를 이용한 확장

![IMG_0125.jpg](IMG%2FIMG_0125.jpg)

- 단점
    - UserDao는 DB Connection에 종속되어있어 자유롭게 확장하기 힘들다

### 인터페이스의 도입

![IMG_0126.jpg](IMG%2FIMG_0126.jpg)

- 단점
    - 초기에 어떤 클래스를 이용할지 결정하는 생성자 코드는 여전히 UserDao내에 정의되어있다.
    
           Why? 아직 분리되지 않은 관심사가 UserDao 안에 존재
    

### 관계설정 책임의 분리

- 종속될 클래스를 결정하는 것 역시 관계를 설정해주는 것에 관한 관심이므로, 분리한다.
- 의존관계를 맺어준다.
- 관계 설정 책임을 클라이언트에게 넘기고, 다형성을 활용하여 관계 설정한다.

![IMG_0127 2.jpg](IMG%2FIMG_0127%202.jpg)

### 원칙과 패턴

- 개방 폐쇄 원칙
    - 객체지향 설계 원칙 중 하나
    - 클래스나 모듈은 확장에는 열려 있고 (자신의 관심사와 무관한) 변경에는 닫혀 있어야 한다.
- 높은 응집도와 낮은 결합도
    - 응집도가 높다 = 변화가 있을 때 모듈에서 많은 부분이 변한다.
    - 결합도가 낮다 = 변화가 있을 때 외부에 변화를 요구하는 정도가 낮다.
- 전략 패턴
    - 변경이 필요한 부분을 분리하여 필요에 따라 바꿔서 사용할 수 있도록 하는 디자인 패턴

## 1.4 제어의 역전 (IoC)

- UserDao의 클라이언트를 UserDaoTest에 두었는데, 이는 `테스트` + `관계 설정` 이라는 2개 책임을 가진 것.
- 객체의 생성 방법을 결정하고 만들어진 오브젝트를 돌려주는 역할을 하는 `팩토리` 를 만들어 책임을 분리할 수 있다.
- 팩토리는 실제 로직을 가진 오브젝트들의 관계를 설정하는 **설계도**의 역할을 한다.
- 일반적으로 프로그램의 흐름은 자신이 사용할 오브젝트를 스스로 선택/생성하는 것이다. (사용자가 제어하는 구조)
- 제어의 역전이란 오브젝트 자신은 어디서 사용되는지 모른 채 제어 권한을 다른 대상에 위임하는 것이다. (특별한 오브젝트가 제어하는 구조)
    - ex. 컨테이너 안에서 동작하는 구조들 (서블릿, JSP, EJB)
    - ex. 상위 템플릿 메소드가 필요할 때 기능을 호출하는 템플릿 메소드 패턴
    - ex. 프레임워크 (애플리케이션 코드는 라이브러리를 사용하고, 프레임워크는 애플리케이션 코드를 사용한다.)
- 제어의 역전에서는 프레임워크/컨테이너와 같이 **컴포넌트의 생성, 관계설정, 사용, 생명주기 관리 등을 담당하는 오브젝트**가 필요하다. 하나하나 만들기에는 규모가 커질수록 어렵기 때문에, 애플리케이션 전반에 걸쳐 IoC를 본격적으로 사용하려면 프레임워크의 도움을 받는 것이 유리하다.

## 1.5  스프링의 IoC

- 빈 : 스프링이 직접 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
- 빈팩토리(bean Factory) :빈의 생성과 관계제어를 담당하는 IoC 오브젝트 팩토리
- 애플리케이션 컨텍스트 : 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC엔진

- DaoFactrory 스프링적용

![IMG_0133.jpg](IMG%2FIMG_0133.jpg)

- 애노테이션 적용을 통해 스프링 프레임워크에서의 설정정보 제공
    - 애노테이션 : 프로그램 실행 관점에서 프로그램이 처리할 메인데이터가 아니라 실행과정에서 데이터를 어

![IMG_0134.jpg](IMG%2FIMG_0134.jpg)

- getBean()의 리턴타입은 object이기 때문에 두번째 파라미터 지정을 통해  사용자가 어떤 타입을 리턴받아야하는지 미리 지정해주는것이다.
- 애플리케이션 컨텍스트를 사용했을때의 장점
    - 클라이언트들은 구체적인 팩토리 클래스를 알 필요가 없고 생성해야할 필요도 없으며 일관된 방식으로 오브젝트를 가져올 수 있다.
    - 종합 IoC서비스를 제공해준다. (ex. 자동생성, 후처리, 외부시스템과의 연동 etc)
    - 빈을 검색하는 다양한 방법을 제공한다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

스프링은 호출마다 새로운 객체를 생성하지 않고 매번 동일한 오브젝트를 반환함.

<aside>
💡 싱글톤패턴 : 클래스의 오브젝트를 단 하나만 생성해 이를 애플리케이션의 여러곳에서 공유하는 패턴

</aside>

- 싱글톤 패턴의 한계
    - 생성자가 private로 제한되어 있어 상속이 불가능하다.
    - 테스트의 어려움
    - 서버에서 클래스로더 구성에 따라 하나 이상의 오브젝트가 만들어질 수 있어 싱글톤의 가치를 보장할 수 없다.
    - 전역상태를 만들 수 있기 객체지향에서 권장하지 않는 프로그래밍모델이 될 수 있다.

그러나 스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는것을 선호하며 싱글톤 레지스트리(직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능)을 제공한다. 

- 스프링빈의 스코프 : 빈이 생성되고 존재하고 적용되는 범위이며 스프링빈의 기본 스코프는 싱글톤이다. (cf. 프로토타입스코프, 요청스코프, 세션스코프 etc)

## 1.7 의존관계주입(DI)

- 의존관계: 의존관계에서 의존대상이 변하면 그 변화가 다른 대상에 영향이 전달되며 방향성을 가진다.
- 구현클래스와 인터페이스사이에 의존관계를 만들어두면 서로 결합도가 낮아져 변화의 영향을 덜 받는 형태로 만들 수 있다.
- 의존관계 주입의 조건
    - 클래스 모델이나 코드에서 런타임 시점의 의존관계가 드러나면 안됨.
    - 런타임 시점의 의존관계는 컨테이너나 팩토리같은 제 3의 존재가 결정함.
    - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공하여 만든다.
- UserDao 클래와 ConnectionMaker 사이의 의존관계 주입

![IMG_0136.jpg](IMG%2FIMG_0136.jpg)

- 의존관계 검색(DL)
    - 자신이 필요로 하는 오브젝트를 능동적으로 찾음.
    - getBean()메소드가 의존관계 검색 시 사용됨.
    - 검색하는 오브젝트는 스프링의 빈일 필요가 없다.

- 메소드를 이용한 의존관계 주입
    - 생성자에 파라미터를 만들어둔 뒤 이를 통해 DI컨테이너가ㅏ 의존할 오브젝트 레퍼런스를넘겨주는 방식
    - 수정자(setter) 메소드를 이용한 주입(파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장(
    - 일반메소드릉 이용한 주입(여러개의 파라미터를 받을 수 있다

## 1.8 xml을 이용한 설정

- xml의 특징
    - 단순한 텍스트 파일
    - 별도의 빌드 작업이 필요 없다.
    - 사람의 눈으로 이해하기 쉽다.

![IMG_0137.jpg](IMG%2FIMG_0137.jpg)

**자바와 XML 비교**

- 빈 설정파일
    - `자바`: `@Configuration`
    - `XML`: `<beans>`
- 빈 이름
    - `자바`: `@Bean methodName()`
    - `XML`: `<bean id="methodName">`
- 빈 클래스
    - `자바`: `return new BeanClass();`
    - `XML`: `class="a.b.c...BeanClass">`